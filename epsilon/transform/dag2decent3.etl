import "../libraries/decent/common.eol";
import "../libraries/decent/logging.eol";

pre dagInitPre {

  //Some initialization
  //More generic (might be simplified)
  var step = "dag2decent3"; 
  ("Running "+step).log(1);
  var start = Native("java.lang.System").currentTimeMillis();
  /********************************** INIT (1x) *******************************/
  var Model = DECENT!Model.allInstances().first();
}

post dagInitPost{
  //DONE: Note that this doesn't work as it is a global graph
  //artifact states are a projection on this graph and it would be 
  //more appropriate to assemble these projections which would 
  //probably result in the very same sequence of states as the one
  //produced by the sequence of actions 
  
  //TODO: The DAG is nonetheless potentially relevant for the 
  //CFA analysis or at least some variations thereof
  ("Post processing... ").log(1);
  //checkCorrectStateSequence();
  assignAgentStateSequence();
  assignAgentStatesToActivities();
   
 
  	var end = Native("java.lang.System").currentTimeMillis();
  	var duration = end - start;
	Model.content.add(step);
  	Model.addStep(step,duration.toMinutes().round(5));
	("Duration: "+duration.toMinutes().round(5)).log(1);
  
}

//TODO: this should be elsewhere
//TODO: may need to add initial state
//NOTE: given a set of activities resulting in target artifact states with ID=N
//      an agent is said to be in an agent state with ID=N when they performed 
//      these activities resulting in them moving to agent state with ID=M after
//		these activities were peformed while obtaining experience delta(E(M,N) as 
// 		a result, where E(M) is defined as a set of values describing the agent in 
//		agent state with ID=M and E(N) is a set of values describing the agent in
//		agent state with ID=N.
//		Consequently, an agent does not have "final" state, but rather only a 
//		state in which they performed the last observed activities, with the 
//		experience obtained from these activities not being considered as there are
//		no further activities where this experience would play a role.
//		However, this experience may need to be considered when evaluating the 
//		overall experience of a developer.		 
operation Any assignAgentStatesToActivities() {
  ("Adding agent states to activities... ").log(2);
  for (s in DECENT!AgentState.allInstances()) {
  	s.activities.clear();
  }
  
  for (a in DECENT!Agent.allInstances()) {
  	("  Agent: "+a.name).log(3);
  	for (s in a.states) {
  		if (s.previous.isDefined()) {
	  		s.previous.activities.addAll(a.activities.select(ax|ax.targetState.ID = s.ID));
  		}
  	}
  }
}

@cached
operation DAG!Node findPreviousStateInParentNodes(state : DECENT!AgentState) {
	if (self.parents.size() > 0) {
		for (p in self.parents) {
			state.previous = state.agent.states.select(x|x.name = p.name).first();
			if (state.previous.isUndefined()) {
				p.findPreviousStateInParentNodes(state);
			}
		}
	}
}

@cached
operation DAG!Node findPreviousStateNodeInParentNodes(parent : DAG!Node) : DAG!Node {
	var node;
	if (self.parents.size() > 0 and self <> parent) {
		for (p in self.parents) {
			node = p.findPreviousStateNodeInParentNodes(parent);
			if (node.isDefined()) {
				return node; //break;
			}
		}
	} 
	if (self = parent) {
		node = self;
	}
	return node;
}


operation Any assignAgentStateSequence() {
  ("Adding agent state sequence... ").log(2);
  for (s in DECENT!AgentState.allInstances()) {
  	s.previous = null;
  }
  
  var nodes = DAG!Graph.allInstances().first.nodes;
  for (a in DECENT!Agent.allInstances()) {
  	("  Agent: "+a.name).log(3);
  	var count = 0;
  	for (s in a.states) {
  		("  State: "+s.ID + " ("+count+"/"+a.states.size()+")").log(3);
  		var node = nodes.select(n|n.name = s.name).first();
		node.findPreviousStateInParentNodes(s);
		if (s.previous.isUndefined() and count > 0) {
			//TODO: most of these are harmless for first commits but sometimes the chains are broken - e.g. rebase? 
			//TODO: how to handle these? simply fall back to last known change? what if parallel?
			(    "Failed to assign previous state for state "+s.ID+" / "+s.name+"!").log(1);
			(    "Corresponding node has "+node.parents.size()+" parents!").log(1);
		} else {
		}
		count = count + 1;
  	}
  }
}

operation Any checkCorrectStateSequence() {
  ("Checking correct artifact state sequences... ").log(2);
  var nodes = DAG!Graph.allInstances().first.nodes;
  for (a in DECENT!Artifact.allInstances()) {
  	("  Artifact: "+a.name).log(3);
  	for (s in a.states) {
		var node = nodes.select(n|n.name = s.name).first();
		for (p in s.previous) {
				var parentNode = nodes.select(n|n.name = p.name).first();
			
			var currentNodeX = node.findPreviousStateNodeInParentNodes(parentNode);
			if (not currentNodeX.isDefined()) {
				(    "Failed to find previous state node in node parents tree for state "+s.ID+"!").log(1);
			}
		}
  	}
  }
}