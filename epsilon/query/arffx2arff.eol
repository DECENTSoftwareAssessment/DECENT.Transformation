import "../libraries/arff/common.eol";
import "../libraries/decent/common.eol";
import "../libraries/decent/logging.eol";

"Running arffx2csv".log(1);
var start = Native("java.lang.System").currentTimeMillis();


var s = ",";
var targetAttributes = new Map;
targetAttributes.put("Artifact.Target.BugFix.AverageWeight.Local",0.1);
targetAttributes.put("Artifact.Target.Refactoring.AverageWeight.Local",0.1);

var modelFile = new Native("java.io.File") (ARFFx.getModelFile());

//var CONFIDENCE = "CONFIDENCE".getARFFAttribute();
//var LABEL = "LABEL".getARFFAttribute();

//TODO: move to common
//TODO: remove once established at earlier steps
var nestedAnonymousClassFilter = "\"[\\w]+\\$[\\d]+.*\"";

var threshold = 100;
var bag = new OrderedSet();

for (arffx in ARFFx!Model.allInstances()) {
	arffx.checkTargetAttributes(targetAttributes);
	arffx.checkForCompleteness();
	arffx.assignClassAndConfidence(targetAttributes);
	if (arffx.data.size() > threshold or arffx.meta.get("ARFFx.Type") = "artifact") {
		//temporary workaround
		arffx.name=arffx.name.replace("-1",arffx.meta.get("DECENT.Agent.Name"));
		
		var filename = modelFile.getParent()+"/"+arffx.name+".csv";
		//note that this is about 30%+ slower
		//arffx.exportAll(filename+".all.csv",s);
		var filter = "filters/custom-current";
		arffx.exportAttributes(filter+"-"+arffx.meta.get("ARFFx.Type")+"-"+arffx.meta.get("DECENT.ArtifactType")+"-last");
		arffx.exportFiltered(filename,filter,targetAttributes,s);
	} else {
		bag.add(arffx);
	}
}

//Cheap workaround... quite slow too?
var types = bag.collect(x|x.meta.get("DECENT.ArtifactType")).asOrderedSet();
for (type in types) {
	//cheap trick
	var modelName = bag.first().name.replace("-.+","");
	var data = new OrderedSet();
	var filename = modelFile.getParent()+"/"+modelName+"-agents-small-contribuotrs-"+type+".csv";
	var file = new Native("java.io.File") (filename);
	var writer = new Native("java.io.FileWriter") (file);
	var filter = "filters/custom-current";
	var h = false;
	for (a in bag.select(x|x.meta.get("ARFFx.Type") = "agent" and x.meta.get("DECENT.ArtifactType") = type)) {
		var attributes = a.attributes;
		if (filter.isDefined()) {
			var selected = filter.getSelectedAttributes();
			for (k in targetAttributes.keySet()) {
				selected.add("CONFIDENCE."+k);
				selected.add("LABEL."+k);		
			}		
			//Note: This takes a subset of the available attributes that are 
			//also within the filtered set, rather than simply taking the 
			//filtered set, which may include unavailable attributes as well 
			attributes = attributes.select(x|selected.contains(x.name));
		}
		if (not h) {
			attributes.collect(x|x.name).concat(s).printlno(writer);
			h = true;
		} 

		var NameAttribute = "Artifact.Name".getARFFAttribute(a);		
		for (i in a.data.select(x|not x.getValue(NameAttribute).matches(nestedAnonymousClassFilter))) {
		//for (i in a.data) {
			//Note: See above on why attributes rather than selected is used 
			i.getFilteredValues(s,attributes).printlno(writer);
			//TODO: order seems to be ensured anyways
			//i.getSafeOrderValues(s, attributes).printlno();
		}
	}
	writer.close();
}



var end = Native("java.lang.System").currentTimeMillis();
var duration = end - start;
("Duration: "+duration.toMinutes().round(5)).log(1);


//validateFAMIXCoverage(CodeArtifactType);


operation ARFFx!Model checkTargetAttributes(targetAttributes : Map) {
	var notFound = targetAttributes.keySet().select(x|not self.attributes.exists(a|a.name = x));
	for (a in notFound) {
		targetAttributes.remove(a);
	}
}

operation ARFFx!Model exportAttributes(filename : String) {
	var file = new Native("java.io.File") (filename);
	var writer = new Native("java.io.FileWriter") (file);
	
	self.attributes.collect(x|x.name).concat("\n").printlno(writer);

	writer.close();
}


operation ARFFx!Model exportAll(filename : String, s : String) {
	var file = new Native("java.io.File") (filename);
	var writer = new Native("java.io.FileWriter") (file);
	
	self.attributes.collect(x|x.name).concat(s).printlno(writer);

	var NameAttribute = "Artifact.Name".getARFFAttribute(self);		
	for (i in self.data.select(x|not x.getValue(NameAttribute).matches(nestedAnonymousClassFilter))) {
//	for (i in self.data) {
		i.getValues(s).substring(1).printlno(writer);
		//TODO: order seems to be ensured anyways
		//i.getSafeOrderValues(s, attributes).printlno();
	}
	
	writer.close();
}

//slow? 
operation ARFFx!Model assignClassAndConfidence(targetAttributes : Map) {
	for (baseAttribute in targetAttributes.keySet()) {
		for (i in self.data) {
			i.assignClassAndConfidence(baseAttribute, targetAttributes.get(baseAttribute));
		}
	}
}

operation ARFFx!Model checkForCompleteness() {
	var line = 1;
	var NameAttribute = "Artifact.Name".getARFFAttribute(self);		
	for (i in self.data.select(x|not x.getValue(NameAttribute).matches(nestedAnonymousClassFilter))) {
	//for (i in self.data) {
		line = line+1;
		if (i.values.size() <> self.attributes.size()) {
			(self.name+" : Line "+line+" : Value and attribute counts do not match : " + i.values.size() +" vs "+ self.attributes.size()).log(1);
			(i.getValues(s).substring(1)).log(1);
			i.printMissingAttributes();
		}
	}
}

operation ARFFx!Instance printMissingAttributes() {
	for (a in self.eContainer.attributes) {
		if (not self.values.exists(v|v.ofAttribute = a)) {
			("  Missing attribute: "+a.name).log(1);
		}
	}
}

//deprecated: very very very slow! also NO LONGER CORRECT!
operation ARFFx!Model filterAttributes(filter : String, s : String) {
	if (filter.isDefined()) {
		var selected = filter.getSelectedAttributes();
		
		//Note: This takes a subset of the available attributes that are 
		//also within the filtered set, rather than simply taking the 
		//filtered set, which may include unavailable attributes as well 
		var attributes = self.attributes.select(x|not selected.contains(x.name));
		for (v in ARFFx!Value.all().select(x|attributes.contains(x.ofAttribute))) {
			delete v;
		}
		for (a in attributes) {
			delete a;
		}
	}
}


operation ARFFx!Model exportFiltered(filename : String, filter : String, targetAttributes : Map, s : String) {
	var file = new Native("java.io.File") (filename);
	var writer = new Native("java.io.FileWriter") (file);
	var attributes = self.attributes;

	if (filter.isDefined()) {
		var selected = filter.getSelectedAttributes();
		for (k in targetAttributes.keySet()) {
			selected.add("CONFIDENCE."+k);
			selected.add("LABEL."+k);		
		}		
		//Note: This takes a subset of the available attributes that are 
		//also within the filtered set, rather than simply taking the 
		//filtered set, which may include unavailable attributes as well 
		attributes = attributes.select(x|selected.contains(x.name));
	}

	attributes.collect(x|x.name).concat(s).printlno(writer);
	
	var NameAttribute = "Artifact.Name".getARFFAttribute(self);		
	for (i in self.data.select(x|not x.getValue(NameAttribute).matches(nestedAnonymousClassFilter))) {
	//for (i in self.data) {
		//Note: See above on why attributes rather than selected is used 
		i.getFilteredValues(s,attributes).printlno(writer);
		//TODO: order seems to be ensured anyways
		//i.getSafeOrderValues(s, attributes).printlno();
	}
	
	writer.close();
}

operation ARFFx!Instance assignClassAndConfidence(baseAttribute : String, threshold : Real) : OrderedSet {
	var confidenceAttribute = "CONFIDENCE."+baseAttribute;
	var labelAttribute = "LABEL."+baseAttribute;
	
	//TODO: add attributes to filter
	var base = self.getValue(baseAttribute.getARFFAttribute(self.eContainer()));
	var label = "false";
	var confidence = "high";
	if (base.asDouble() > threshold) {
		label = "true";
	}
	//TODO: also export as parameters
	if (base.asDouble() < 1.1*threshold and base.asDouble() > 0.9*threshold) {
		confidence = "low";
	}
	self.addValue(confidence, confidenceAttribute);
	self.addValue(label, labelAttribute);
}

operation ARFFx!Instance getFilteredValues(s : String, filter : Collection) : String {
	var line = "";
	for (v in self.values.select(x|filter.contains(x.ofAttribute))) {
		line = line  + s + v.content;
	}
	return line.replace("NaN","0.0").substring(1); //Substring? why?
}

operation ARFFx!Instance getValues(s : String) : String {
	var line = "";
	for (v in self.values) {
		line = line  + s + v.content;
		//line = line  + s + v.ofAttribute.name+"="+v.content;
	}
	return line.replace("NaN","0.0").substring(0); //Substring? why?
}

//deprecated
operation ARFFx!Instance getSafeOrderValues(s : String, attributes : Sequence) : String {
	var line = "";
	for (a in attributes) {
		line = line + i.getValue(a) + s;
	}
	return line;
}
